# 微服务架构分布式事务处理

分布式事务分为传统分布式事务，微服务涉及的分布式事务，传统分布式事务处理就不多说了，只要实现了XA分布式事务规范，就可以对数据库进行分布式事务处理，我们主要探讨的是微服务架构的分布式服务。

首先，对于微服务架构来说，数据访问变得更加复杂，这是因为数据都是微服务私有的，唯一可访问的方式就是通过 API。这种打包数据访问方式使得微服务之间松耦合，并且彼此之间独立，更容易进行性能扩展。

事务就是一个会话过程中，对上下文的影响是一致的，要么所有的更改都做了，要么所有的更变都撤销掉。

事务是为了保障业务数据的完整性和准确性的。

分布式事务，常见的两个处理办法就是两段式提交(TCC)和补偿。
两段式提交典型的就是XA，有个事务协调器，告诉大家，来都准备好提交，大家回复，都准备好了，然后协调器告诉大家，一起提交，大家都提交了。
补偿比较好理解，先处理业务，然后定时或者回调里，检查状态是不是一致的，如果不一致采用某个策略，强制状态到某个结束状态（一般是失败状态），然后就世界太平了。典型的就是冲正操作。

复杂的业务交互过程中，不建议使用强一致性的分布式事务。解决分布式事务的最好办法就是不考虑分布式事务。就像刚说的问题一样，把分布式的事务过程拆解成多个中间状态，中间状态的东西不允许用户直接操作，等状态都一致成功，或者检测到不一致的时候全部失败掉。就解耦了这个强一致性的过程。

比如下面代码，就能根据中间状态进行事务回滚处理。
```java
try{
    // 1.操作数据,失败则会抛出异常
    boolean result = UserRepository.update(userModel);

    // 2.如果上面操作数据库成功,则调用service2 保存用户相关其它信息
    //  如果调用service2服务失败，则抛出异常
    if(result){
        boolean httpResult = httpClient.post(serviceURL2 , userModel);
        if(httpResult){
            throw new RuntimeException("service2 fail");
        }
    }

}catch (Exception ex){
    throw new RuntimeException(ex.message);
}
```

所以在微服务架构里面对分布式事务的问题，我们可以通过调整业务代码来进行避免。

参考资料
[为什么说分布式事务不再适用于微服务架构](http://blog.csdn.net/javahongxi/article/details/54177741)